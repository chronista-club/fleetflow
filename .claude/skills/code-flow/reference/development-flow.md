# Development Flow - 開発フロー

## 概要

Code Flowにおける開発フローは、以下の4つのフェーズで構成されます：

```
🎯 ヒアリング → 📝 SDG → 💻 実装 → 🔄 Living Documentation
```

各フェーズは明確な役割を持ち、シームレスに次のフェーズへ移行します。

## フロー全体図

```
┌─────────────────────────────────────────────────────┐
│  ユーザーからの要望・タスク                             │
└──────────────────┬──────────────────────────────────┘
                   ↓
    ┌──────────────────────────────────┐
    │  🎯 Phase 1: ヒアリング             │
    │                                  │
    │  ❌ いきなり「実装します」           │
    │  ✅ 「まず確認させてください」       │
    │                                  │
    │  ┌─────────────────────┐         │
    │  │ AskUserQuestion     │         │
    │  │ - 選択肢提示         │         │
    │  │ - 段階的な深掘り      │         │
    │  │ - 要件の明確化       │         │
    │  └─────────────────────┘         │
    └──────────────┬───────────────────┘
                   │
                   │ 十分な情報が集まった
                   ↓
    ┌──────────────────────────────────┐
    │  📝 Phase 2: SDG                 │
    │                                  │
    │  spec-design-guideスキル使用      │
    │                                  │
    │  ┌─────────────────────┐         │
    │  │ SPEC.md作成         │         │
    │  │ - コンセプト         │         │
    │  │ - 仕様              │         │
    │  │ - 哲学的考察         │         │
    │  └─────────────────────┘         │
    │  ┌─────────────────────┐         │
    │  │ DESIGN.md作成       │         │
    │  │ - データモデル       │         │
    │  │ - アーキテクチャ      │         │
    │  │ - 実装手法          │         │
    │  │ - チェックリスト     │         │
    │  └─────────────────────┘         │
    └──────────────┬───────────────────┘
                   ↓
    ┌──────────────────────────────────┐
    │  💻 Phase 3: 実装                 │
    │                                  │
    │  DESIGN.mdの設計に従う            │
    │                                  │
    │  ┌─────────────────────┐         │
    │  │ チェックリスト駆動    │         │
    │  │ - 一つずつ実装       │         │
    │  │ - テストも作成       │         │
    │  │ - 進捗を可視化       │         │
    │  └─────────────────────┘         │
    └──────────────┬───────────────────┘
                   ↓
    ┌──────────────────────────────────┐
    │  🔄 Phase 4: Living Documentation│
    │                                  │
    │  ドキュメントとコードの同期         │
    │                                  │
    │  ┌─────────────────────┐         │
    │  │ 同期チェック         │         │
    │  │ - SPEC.mdと一致?    │         │
    │  │ - DESIGN.mdと一致?  │         │
    │  │ - チェックリスト完了? │         │
    │  └─────────────────────┘         │
    │  ┌─────────────────────┐         │
    │  │ 変更履歴記録         │         │
    │  │ - なぜ変更したか     │         │
    │  │ - どこに影響するか   │         │
    │  │ - コミットハッシュ   │         │
    │  └─────────────────────┘         │
    │  ┌─────────────────────┐         │
    │  │ コミット            │         │
    │  │ - コード            │         │
    │  │ - ドキュメント       │         │
    │  │ - 同時にコミット     │         │
    │  └─────────────────────┘         │
    └──────────────┬───────────────────┘
                   ↓
            ┌──────────┐
            │  ✅ 完了  │
            └──────────┘
```

## Phase 1: ヒアリングフェーズ 🎯

### 目的
いきなり実装せず、まず要件を明確化する

### トリガー
ユーザーからタスク・要望を受け取った時

### プロセス

#### 1. 最初の反応

**❌ NG例**:
```
ユーザー: 「検索機能を追加して」
Claude: 「わかりました。ベクトル検索を実装します！」
```

**✅ OK例**:
```
ユーザー: 「検索機能を追加して」
Claude: 「検索機能の追加ですね。
まず確認させてください...」
```

#### 2. 質問の設計

**第1段階: 大枠の理解**
- 何を作りたいか？（What）
- なぜ必要か？（Why）
- 誰が使うか？（Who）

**第2段階: 詳細の確認**
- どう動くべきか？（How）
- 既存機能との関係は？
- 制約条件は？

**第3段階: 技術的な選択**
- パフォーマンス要件は？
- セキュリティ考慮事項は？
- 互換性の方針は？

#### 3. AskUserQuestionツールの使用

```javascript
{
  "questions": [
    {
      "question": "検索機能の種類を教えてください",
      "header": "検索方法",
      "multiSelect": false,
      "options": [
        {
          "label": "キーワード検索",
          "description": "タイトルや本文から文字列で検索"
        },
        {
          "label": "ベクトル検索",
          "description": "意味的に類似したメモリを検索"
        },
        {
          "label": "ハイブリッド検索",
          "description": "両方を組み合わせて検索"
        },
        {
          "label": "その他",
          "description": "別の検索方法を希望"
        }
      ]
    }
  ]
}
```

#### 4. 段階的な深掘り

```
ユーザー: 「検索機能を追加して」
  ↓
Claude: [Q1] 検索方法は？
  ↓
ユーザー: 「ベクトル検索」
  ↓
Claude: [Q2] 検索範囲は？
  ↓
ユーザー: 「WorkspaceとProject」
  ↓
Claude: [Q3] 結果の表示順は？
  ↓
ユーザー: 「類似度の高い順」
  ↓
Claude: 「ありがとうございます。
要件が明確になりましたので、開発のレールに乗ります。」
```

### 完了条件

- ✅ ユーザーの要望が明確
- ✅ 技術的な実現方法の方向性が見えた
- ✅ SPEC.mdに記載すべき内容が整理できた
- ✅ 曖昧な点が残っていない

### 成果物

- 明確化された要件（口頭）
- 次フェーズで作成するSPEC.mdの骨子

詳細: [ヒアリングファースト](hearing-first.md)

## Phase 2: SDGフェーズ 📝

### 目的
仕様と設計をドキュメントとして記録する

### トリガー
ヒアリングフェーズが完了し、十分な情報が集まった時

### プロセス

#### 1. 移行の宣言

```
Claude: 「ご回答ありがとうございます。
要件が明確になりましたので、以下の流れで進めます：

1. SPEC.md作成（仕様の記録）
2. DESIGN.md作成（設計の記録）
3. 実装開始

まずSPEC.mdを作成します...」
```

#### 2. SPEC.md作成（What & Why）

```markdown
# ベクトル検索 - 仕様書

## コンセプト

### ビジョン
ユーザーがメモリを意味的に検索できるようにし、
キーワードが一致しなくても類似した内容のメモリを発見できる。

### 哲学・設計原則
- **意味的検索**: キーワード一致ではなく意味の類似性で検索
- **スコープ対応**: Workspace/Projectごとに検索範囲を限定
- **高速性**: 大量のメモリでも素早く検索結果を返す

## 仕様

### 機能仕様

#### FS-003: ベクトル検索

**目的**: 意味的に類似したメモリを検索する

**入力**:
- 検索クエリ（文字列）
- スコープ（Workspace | Project）
- 件数制限（オプション、デフォルト10件）

**出力**:
- 類似度順のメモリリスト
- 各メモリの類似度スコア

**振る舞い**:
1. 検索クエリを埋め込みベクトルに変換
2. Qdrantでベクトル検索実行
3. スコープでフィルタリング
4. 類似度の高い順にソート
5. 上位N件を返す

**制約**:
- 検索クエリは1文字以上必須
- 件数制限は最大100件

### 非機能仕様

- **パフォーマンス**: 1000件のメモリで100ms以内
- **セキュリティ**: スコープ外のメモリは検索結果に含めない
- **互換性**: 既存のメモリ取得APIと同じ形式で返す

## 変更履歴

### 2025-01-18: ベクトル検索機能追加
- **理由**: ヒアリングで明確化されたユーザーニーズ
- **影響**: 新規機能追加、既存機能への影響なし
- **コミット**: (これから実装)
```

#### 3. DESIGN.md作成（How）

```markdown
# ベクトル検索 - 設計書

## データモデル

### 構造定義

\`\`\`rust
pub struct SearchQuery {
    pub query: String,
    pub scope: Scope,
    pub limit: Option<usize>,
}

pub struct SearchResult {
    pub memory: Creare,
    pub score: f32,
}
\`\`\`

## アーキテクチャ

### コンポーネント構成

\`\`\`
SearchQuery → Embedding → QdrantSearch → ScopeFilter → Sort → SearchResult
\`\`\`

### コンポーネント詳細

#### Embedding
**責務**: クエリ文字列を埋め込みベクトルに変換
**インターフェース**:
\`\`\`rust
pub trait EmbeddingService {
    async fn embed(&self, text: &str) -> Result<Vec<f32>>;
}
\`\`\`

#### QdrantSearch
**責務**: Qdrantでベクトル検索を実行
**インターフェース**:
\`\`\`rust
pub trait VectorStore {
    async fn search(
        &self,
        vector: Vec<f32>,
        limit: usize
    ) -> Result<Vec<SearchResult>>;
}
\`\`\`

## 実装手法

### アルゴリズム

1. **埋め込み生成**
   - OpenAI Embeddings APIを使用
   - text-embedding-3-small（1536次元）

2. **ベクトル検索**
   - Qdrantのコサイン類似度検索
   - スコアしきい値: 0.7以上

3. **スコープフィルタ**
   - Qdrantのfilter機能を使用
   - `scope.workspace_id`または`scope.project_id`で絞り込み

### エラーハンドリング

\`\`\`rust
#[derive(Error, Debug)]
pub enum SearchError {
    #[error("Empty query")]
    EmptyQuery,

    #[error("Embedding service error: {0}")]
    EmbeddingError(String),

    #[error("Vector store error: {0}")]
    VectorStoreError(String),
}
\`\`\`

## テスト戦略

### ユニットテスト
- [ ] SearchQuery構造体のバリデーション
- [ ] スコープフィルタのロジック
- [ ] ソート順の正確性

### 統合テスト
- [ ] 実際のQdrantを使った検索
- [ ] スコープ違いのメモリが除外されること
- [ ] 類似度順にソートされること

## 実装チェックリスト

- [ ] SearchQuery構造体の作成
- [ ] search()メソッドの実装
- [ ] スコープフィルタの実装
- [ ] エラーハンドリング
- [ ] ユニットテスト作成
- [ ] 統合テスト作成
- [ ] ドキュメント更新

## 変更履歴

### 2025-01-18: 新機能設計
- **理由**: SPEC.mdに基づく設計
- **影響**: `src/module/feature.rs`新規作成
- **コミット**: (これから実装)
```

#### 4. spec/ディレクトリの決定

既存のspec/ディレクトリに対応：
- `spec/03-feature-name/` → 機能関連

新規の場合は連番を割り当て：
- `spec/08-{機能名}/`

### 完了条件

- ✅ SPEC.mdが作成され、要件が明文化されている
- ✅ DESIGN.mdが作成され、実装方針が明確
- ✅ 実装チェックリストが用意されている
- ✅ spec/ディレクトリが適切に決定されている

### 成果物

- SPEC.md（仕様書）
- DESIGN.md（設計書）
- 実装チェックリスト

使用するスキル: [spec-design-guide](../../spec-design-guide/SKILL.md)

## Phase 3: 実装フェーズ 💻

### 目的
DESIGN.mdに基づいてコードを実装する

### トリガー
SPEC.md/DESIGN.mdの作成が完了した時

### プロセス

#### 1. 実装開始の宣言

```
Claude: 「それでは実装を開始します。
DESIGN.mdの実装チェックリストに従って進めます：

実装チェックリスト:
- [ ] SearchQuery構造体の作成
- [ ] search()メソッドの実装
- [ ] スコープフィルタの実装
- [ ] エラーハンドリング
- [ ] ユニットテスト作成
- [ ] 統合テスト作成
- [ ] ドキュメント更新

まずSearchQuery構造体から作成します...」
```

#### 2. チェックリスト駆動開発

```
[実装中の進捗報告]

✅ SearchQuery構造体の作成 - 完了
🔄 search()メソッドの実装 - 進行中
⏳ スコープフィルタの実装 - 未着手
⏳ エラーハンドリング - 未着手
...
```

#### 3. コーディング

**DESIGN.mdの設計に従う**:
```rust
// DESIGN.mdで定義したSearchQuery構造体
pub struct SearchQuery {
    pub query: String,
    pub scope: Scope,
    pub limit: Option<usize>,
}

// DESIGN.mdで定義したsearch()メソッド
pub async fn search(query: SearchQuery) -> Result<Vec<SearchResult>> {
    // 1. 埋め込み生成
    let vector = embedding_service.embed(&query.query).await?;

    // 2. ベクトル検索
    let results = vector_store.search(vector, query.limit.unwrap_or(10)).await?;

    // 3. スコープフィルタ
    let filtered = filter_by_scope(results, &query.scope);

    Ok(filtered)
}
```

#### 4. テスト作成

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // DESIGN.mdのテスト戦略に基づく
    #[test]
    fn test_search_query_validation() {
        // 空クエリはエラー
        let result = SearchQuery::new("", Scope::workspace("ws1"), None);
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_scope_filter() {
        // スコープ違いのメモリは除外される
        // ...
    }
}
```

#### 5. 進捗の可視化

実装チェックリストを随時更新：
```markdown
## 実装チェックリスト

- [x] SearchQuery構造体の作成
- [x] search()メソッドの実装
- [x] スコープフィルタの実装
- [x] エラーハンドリング
- [x] ユニットテスト作成
- [ ] 統合テスト作成 ← 現在ここ
- [ ] ドキュメント更新
```

### 完了条件

- ✅ 実装チェックリストが全て完了
- ✅ ユニットテストが通っている
- ✅ 統合テストが通っている（あれば）
- ✅ コードが動作している

### 成果物

- 実装されたコード
- テストコード
- 更新された実装チェックリスト

## Phase 4: Living Documentationフェーズ 🔄

### 目的
ドキュメントとコードの同期を確認・維持する

### トリガー
実装が完了した時

### プロセス

#### 1. 同期チェック

```
実装完了後の確認:
- ✅ SPEC.mdの仕様と実装が一致しているか？
  → FS-003の入出力・振る舞いと実装が一致

- ✅ DESIGN.mdの設計と実装が一致しているか？
  → データモデル・アーキテクチャと実装が一致

- ✅ 実装チェックリストは全て完了しているか？
  → 全項目にチェックマーク

- ❓ 実装中に仕様や設計が変わったか？
  → 変わった場合はドキュメントを更新
```

#### 2. 乖離の修正

**ケース1: 実装が正しい場合**
```
実装中に「スコアしきい値0.7」だと結果が少なすぎることが判明
→ 実装では0.5に変更
→ DESIGN.mdを更新して一致させる
```

**ケース2: ドキュメントが正しい場合**
```
SPEC.mdでは「最大100件」だが、実装では50件になっている
→ コードを修正して100件に
```

#### 3. 変更履歴の記録

```markdown
## 変更履歴

### 2025-01-18: 検索機能追加
- **理由**: ユーザーが素早く情報を見つけられるようにするため
- **影響**:
  - `src/search/query.rs`を新規作成
  - `src/search/engine.rs`にフィルタ機能追加
  - `src/api/search.rs`に検索エンドポイント追加
- **コミット**: abc1234
- **備考**: 関連度しきい値を0.7→0.5に調整（実装中の検証による）
```

#### 4. コミット

```bash
# コードとドキュメントを同時にコミット
git add \
  src/search/query.rs \
  src/search/engine.rs \
  src/api/search.rs \
  spec/03-search-feature/SPEC.md \
  spec/03-search-feature/DESIGN.md

git commit -m "検索機能追加とドキュメント更新

## コード変更
- src/search/query.rs: SearchQuery構造体とsearch()実装
- src/search/engine.rs: フィルタ機能追加
- src/api/search.rs: 検索エンドポイント追加

## ドキュメント更新
- spec/03-search-feature/SPEC.md: FS-001仕様追加
- spec/03-search-feature/DESIGN.md: 検索設計追加、実装チェックリスト完了

## 理由
ユーザーが素早く情報を見つけられるようにするため。
ヒアリングで明確化された要件に基づく実装。

## 備考
実装中の検証により、関連度しきい値を0.7→0.5に調整
"
```

### 完了条件

- ✅ ドキュメントとコードが完全に同期
- ✅ 変更履歴が記録されている
- ✅ コードとドキュメントがコミットされている
- ✅ 実装チェックリストが全て完了

### 成果物

- 同期されたドキュメントとコード
- 変更履歴
- Gitコミット

使用する原則: [Living Documentation](../../spec-design-guide/reference/living-documentation.md)

## フロー間の移行

### ヒアリング → SDG

**移行のサイン**:
- ユーザーの要望が明確になった
- 技術的な実現方法の方向性が見えた
- SPEC.mdに書ける情報が揃った

**移行時の宣言**:
```
「ご回答ありがとうございます。
要件が明確になりましたので、以下の流れで進めます：

1. SPEC.md作成
2. DESIGN.md作成
3. 実装

まずSPEC.mdを作成します...」
```

### SDG → 実装

**移行のサイン**:
- SPEC.mdが完成した
- DESIGN.mdが完成した
- 実装チェックリストが用意された

**移行時の宣言**:
```
「SPEC.md/DESIGN.mdの作成が完了しました。
それでは実装を開始します。

実装チェックリスト：
- [ ] ...
- [ ] ...

まず〇〇から実装します...」
```

### 実装 → Living Documentation

**移行のサイン**:
- 実装チェックリストが全て完了した
- テストが通った
- コードが動作した

**移行時の宣言**:
```
「実装が完了しました。
ドキュメントとコードの同期を確認します...」
```

## トラブルシューティング

### ヒアリングが不十分だった場合

**症状**: 実装中に要件の曖昧さに気づく

**対処**:
```
1. 実装を一時停止
2. ユーザーに追加のヒアリング
3. SPEC.mdを更新
4. 必要ならDESIGN.mdも更新
5. 実装を再開
```

### 実装中に設計変更が必要になった場合

**症状**: DESIGN.mdの設計では実現できない

**対処**:
```
1. なぜ変更が必要かを明確化
2. DESIGN.mdを更新
3. 変更履歴に記録
4. 実装を継続
```

### ドキュメントとコードが乖離した場合

**症状**: 実装後に不一致が見つかる

**対処**:
```
1. どちらが正しいか判断
2. 正しい方に合わせて修正
3. 変更履歴に記録
4. Living Documentationフェーズを再実行
```

## まとめ

Code Flowの開発フローは、以下の4つのフェーズで構成されます：

1. **🎯 ヒアリングフェーズ**: 要件を明確化
2. **📝 SDGフェーズ**: 仕様・設計を記録
3. **💻 実装フェーズ**: コードを実装
4. **🔄 Living Documentationフェーズ**: 同期を維持

各フェーズは明確な役割を持ち、前のフェーズの成果物を次のフェーズで活用します。
このフローに従うことで、「ユーザーの期待に沿った実装」と「生きたドキュメント」の両方を実現できます。

**キーポイント**:
- フェーズを飛ばさない
- 各フェーズの完了条件を満たす
- フェーズ間の移行を明確に宣言する
- ドキュメントとコードを常に同期させる
