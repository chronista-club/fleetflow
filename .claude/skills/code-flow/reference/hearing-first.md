# Hearing First - ヒアリングファースト手法

## 基本原則

> **「最初のメッセージに対して、いきなり実装せず、まずヒアリングから始める」**

ヒアリングファーストは、開発のレールに自然に乗るための手法です。
要望を受け取ったら、即座に実装やドキュメント作成に入るのではなく、
**一問一答形式で段階的に**要件を明確化し、その後スムーズに開発フローに移行します。

## 手法の定義

ヒアリングファーストは以下を含みます：

1. **実装前に要件を徹底的にヒアリング**
   - コードを書く前に、ユーザーや関係者から要件を詳しく聞き出す
   - 曖昧な部分、不明確な部分を明らかにする

2. **仕様策定前の情報収集プロセス**
   - SPEC.md/DESIGN.mdを書く前に、必要な情報を集める
   - 背景、目的、制約条件などを理解する

## 一問一答形式の重要性

### 従来の方法（複数質問を一度に）

❌ **問題点**:
```
Claude: 「以下を教えてください：
1. 検索方法は？
2. 検索範囲は？
3. 表示順は？
4. パフォーマンス要件は？」

問題:
- 質問が多すぎて圧倒される
- 後の質問は前の回答に依存する可能性
- ユーザーが全てを一度に考える必要がある
- 不自然な会話フロー
```

### 一問一答形式（推奨）

✅ **利点**:
```
Claude: 「検索方法について教えてください。
キーワード検索、ベクトル検索、どちらが良いですか？」
  ↓
ユーザー: 「ベクトル検索」
  ↓
Claude: 「ありがとうございます。
次に、検索範囲について教えてください。
Workspaceスコープ、Projectスコープ、どちらが必要ですか？」
  ↓
ユーザー: 「両方」
  ↓
Claude: 「わかりました。
それでは、結果の表示順はどうしますか？
類似度順、日付順、どちらが良いですか？」

利点:
- 一度に一つのことを考えればよい
- 前の回答に基づいて次の質問を調整できる
- 自然な会話フロー
- ユーザーの負担が少ない
```

## ワークフロー

### 従来の流れ（ヒアリングなし）

```
ユーザー: 「メモリ検索機能を追加して」
   ↓
Claude: 「わかりました。ベクトル検索を実装します！」
   ↓
実装開始
   ↓
❌ 後から「そういう意味じゃなかった」
```

### 一問一答ヒアリングファーストの流れ

```
ユーザー: 「メモリ検索機能を追加して」
   ↓
Claude: 「検索機能の追加ですね。まず確認させてください。」
   ↓
📋 ヒアリングフェーズ（一問一答）
│
├─ Claude: 「Q1: 検索方法は？」
│  ↓
├─ ユーザー: 「ベクトル検索」
│  ↓
├─ Claude: 「Q2: 検索対象のスコープは？」
│  ↓
├─ ユーザー: 「WorkspaceとProject」
│  ↓
├─ Claude: 「Q3: 結果の表示順は？」
│  ↓
├─ ユーザー: 「類似度の高い順」
│  ↓
└─ Claude: 「Q4: 何件まで表示しますか？」
   ↓
   ユーザー: 「デフォルト10件、最大100件」
   ↓
十分な理解が得られた
   ↓
Claude: 「ありがとうございます。要件が明確になりました。」
   ↓
🚂 開発のレールに乗る
│  ├─ SPEC.md作成（What & Why）
│  ├─ DESIGN.md作成（How）
│  └─ 実装
   ↓
✅ ユーザーの期待通りの機能
```

## ヒアリングの技術

### 1. 一問一答の設計

**良い質問の特徴**:
- ✅ 一度に一つの質問
- ✅ 選択肢が具体的
- ✅ 前の回答に基づいて次の質問を調整
- ✅ 段階的に深掘りしていく

**質問の流れ**:
```
第1段階: 大枠の理解
  Q1: 何を作りたいか？（What）
  ↓
  A1を受けて
  ↓
  Q2: なぜ必要か？（Why）
  ↓
  A2を受けて
  ↓

第2段階: 詳細の確認
  Q3: どう動くべきか？（How）
  ↓
  A3を受けて
  ↓
  Q4: 既存機能との関係は？
  ↓
  A4を受けて
  ↓

第3段階: 技術的な選択
  Q5: パフォーマンス要件は？
  ↓
  A5を受けて
  ↓
  Q6: セキュリティ考慮事項は？
  ...
```

### 2. AskUserQuestionツールの使用（一問ずつ）

```javascript
// ✅ 良い例: 一問ずつ
{
  "questions": [
    {
      "question": "検索機能の種類を教えてください",
      "header": "検索方法",
      "multiSelect": false,
      "options": [
        {
          "label": "キーワード検索",
          "description": "タイトルや本文から文字列で検索"
        },
        {
          "label": "ベクトル検索",
          "description": "意味的に類似したメモリを検索"
        },
        {
          "label": "ハイブリッド検索",
          "description": "両方を組み合わせて検索"
        }
      ]
    }
    // ↑ 一つだけ！
  ]
}

// 回答を受け取った後、次の質問
{
  "questions": [
    {
      "question": "検索対象のスコープを教えてください",
      "header": "検索範囲",
      "multiSelect": true,  // ← 前の回答に基づいて調整
      "options": [
        {
          "label": "Workspaceスコープ",
          "description": "ワークスペース全体を検索"
        },
        {
          "label": "Projectスコープ",
          "description": "特定プロジェクト内を検索"
        },
        {
          "label": "Userスコープ",
          "description": "ユーザー個人のメモリを検索"
        }
      ]
    }
  ]
}
```

```javascript
// ❌ 悪い例: 複数質問を一度に
{
  "questions": [
    {
      "question": "検索機能の種類を教えてください",
      "header": "検索方法",
      ...
    },
    {
      "question": "検索対象のスコープを教えてください",
      "header": "検索範囲",
      ...
    },
    {
      "question": "結果の表示順を教えてください",
      "header": "表示順",
      ...
    }
    // ↑ 一度に3つも質問している！
  ]
}
```

### 3. 一問一答の実践例

**完全な会話フロー**:

```
ユーザー: 「認証機能を追加して」
  ↓
Claude: 「認証機能の追加ですね。
まず、認証方法について教えてください。」

[AskUserQuestion - Q1]
Q: 認証方法は？
Options:
  - APIキー認証
  - JWT認証
  - OAuth 2.0
  ↓
ユーザー: 「APIキー認証」
  ↓
Claude: 「APIキー認証ですね。ありがとうございます。
次に、どの範囲で認証が必要か教えてください。」

[AskUserQuestion - Q2]
Q: 認証が必要なのは？
Options:
  - 全てのエンドポイント
  - 特定のエンドポイントのみ
  - 管理機能のみ
  ↓
ユーザー: 「特定のエンドポイントのみ」
  ↓
Claude: 「特定のエンドポイントのみを保護するのですね。
それでは、どのエンドポイントを保護しますか？」

[AskUserQuestion - Q3]
Q: 保護するエンドポイントは？
Options:
  - メモリ作成・更新・削除
  - メモリ検索のみ
  - カスタム指定
  ↓
ユーザー: 「メモリ作成・更新・削除」
  ↓
Claude: 「わかりました。
最後に、ユーザー管理について教えてください。」

[AskUserQuestion - Q4]
Q: ユーザー管理は？
Options:
  - 既存のユーザーDB利用
  - 新規にユーザーテーブル作成
  - 外部サービス連携
  ↓
ユーザー: 「既存のユーザーDB利用」
  ↓
Claude: 「ありがとうございます。
要件が明確になりました：

- 認証方法: APIキー認証
- 認証範囲: 特定エンドポイント（作成・更新・削除）
- ユーザー管理: 既存DB利用

それでは以下の流れで進めます：
1. spec/08-auth-feature/SPEC.md作成
2. spec/08-auth-feature/DESIGN.md作成
3. 実装

まずSPEC.mdから作成します...」
```

### 4. 選択肢オプション vs テキスト入力

ヒアリングでは、状況に応じて**選択肢から選ぶ方式**と**テキスト入力方式**を使い分けます。

#### 選択肢方式（推奨）

**使用場面**:
- 選択肢が明確な場合
- ユーザーの意思決定を助けたい場合
- 標準的なパターンから選んでもらいたい場合

**AskUserQuestionの使用**:
```javascript
{
  "questions": [
    {
      "question": "検索方法を教えてください",
      "header": "検索方法",
      "multiSelect": false,
      "options": [
        {
          "label": "キーワード検索",
          "description": "タイトルや本文から文字列で検索"
        },
        {
          "label": "ベクトル検索",
          "description": "意味的に類似したメモリを検索"
        },
        {
          "label": "ハイブリッド検索",
          "description": "両方を組み合わせて検索"
        },
        {
          "label": "その他",
          "description": "別の検索方法を希望（カスタム入力）"
        }
      ]
    }
  ]
}
```

**メリット**:
- ✅ ユーザーが選びやすい
- ✅ 標準的なパターンを提示できる
- ✅ 想定外の回答を減らせる
- ✅ 必ず「その他」を含めることで柔軟性も確保

#### テキスト入力方式

**使用場面**:
- 選択肢では表現できない具体的な内容
- エラーメッセージやログの内容
- カスタムな要望の詳細
- 「その他」を選んだ後の詳細入力

**自然な会話での促し**:
```
Claude: 「エラーメッセージを教えてください。
コピー&ペーストしていただけると助かります。」

// ユーザーの自由なテキスト入力を待つ

ユーザー: 「Database connection failed: timeout after 30s」

Claude: 「ありがとうございます。
Database connection failedエラーですね...」
```

**複合パターン: 選択肢 + テキスト入力**:
```
[Q1: 選択肢方式]
Claude: 「現在の検索の何が問題か教えてください」
Options:
  - 検索結果が不正確
  - 検索速度が遅い
  - 検索できる範囲が限定的
  - その他（具体的に説明）
  ↓
ユーザー: 「その他」を選択
  ↓
[Q2: テキスト入力方式]
Claude: 「どのような問題があるか、
具体的に教えてください。」
  ↓
ユーザー: 「特定のタグがついたメモリだけ検索したい」
  ↓
Claude: 「なるほど、タグによる絞り込み検索ですね...」
```

#### 使い分けの判断基準

| 状況 | 方式 | 理由 |
|-----|------|------|
| 認証方法の選択 | 選択肢 | APIキー/JWT/OAuth など明確な選択肢 |
| エラーメッセージ | テキスト入力 | 具体的な内容をそのまま知りたい |
| 検索範囲 | 選択肢（複数選択可） | Workspace/Project/User など明確 |
| 改善の具体的な内容 | テキスト入力 | ユーザー固有の要望 |
| パフォーマンス要件 | 選択肢 | 「高速」「標準」「低速でもOK」など |
| カスタムな要求 | テキスト入力 | 想定外のケースに対応 |

#### 実践例: 選択肢 → テキスト入力のフロー

```
ユーザー: 「認証機能を追加して」
  ↓
Claude: 「認証機能の追加ですね。
まず、認証方法について教えてください。」

[Q1: 選択肢方式]
Options:
  - APIキー認証
  - JWT認証
  - OAuth 2.0
  - その他
  ↓
ユーザー: 「その他」
  ↓
Claude: 「どのような認証方法をお考えですか？
具体的に教えてください。」

[Q2: テキスト入力方式]
  ↓
ユーザー: 「SAML 2.0で企業のSSOと連携したい」
  ↓
Claude: 「SAML 2.0によるSSO連携ですね。
次に、どのIDプロバイダーと連携しますか？」

[Q3: テキスト入力方式 or 選択肢方式]
  ↓
...
```

### 5. 前の回答に基づいた質問の調整

**動的な質問の調整例**:

```
Q1: 「検索方法は？」
  ↓
A1: 「ベクトル検索」
  ↓
  [ベクトル検索を選んだので...]
  ↓
Q2: 「ベクトル検索の埋め込みモデルは？」
Options:
  - OpenAI text-embedding-3-small（既存と同じ）
  - OpenAI text-embedding-3-large（高精度）
  - カスタムモデル

vs.

Q1: 「検索方法は？」
  ↓
A1: 「キーワード検索」
  ↓
  [キーワード検索を選んだので...]
  ↓
Q2: 「検索の一致条件は？」
Options:
  - 完全一致
  - 部分一致
  - 前方一致
```

**条件分岐の例**:

```
Q1: 「新機能 or 既存機能の改善？」
  ↓
A1: 「新機能」
  ↓
  [新機能なので...]
  ↓
Q2: 「どのspec/ディレクトリに追加？」
Q3: 「連番は？（08, 09, ...）」

vs.

Q1: 「新機能 or 既存機能の改善？」
  ↓
A1: 「既存機能の改善」
  ↓
  [既存機能の改善なので...]
  ↓
Q2: 「どのspec/を修正？」
Q3: 「何が問題？」
```

## 開発のレールに乗る瞬間

ヒアリングから開発へのスムーズな移行のサイン：

✅ **ヒアリング完了の条件**
- 必要な質問が全て終わった
- ユーザーの要望が明確になった
- 曖昧な点がなくなった
- 技術的な実現方法の方向性が見えた
- SPEC.mdに書ける情報が揃った

✅ **移行時の宣言**
```
「ご回答ありがとうございます。
要件が明確になりましたので、以下の流れで進めます：

【ヒアリング結果のサマリ】
- 項目1: 回答1
- 項目2: 回答2
- 項目3: 回答3
...

【開発フロー】
1. SPEC.mdに仕様を記録
2. DESIGN.mdに設計を記録
3. 実装開始

まずSPEC.mdを作成します...」
```

## ヒアリング例

### 例1: 新機能追加（一問一答）

```
ユーザー: 「メモリ検索機能を追加して」
  ↓
Claude: 「メモリ検索機能の追加ですね。
まず、検索方法について教えてください。」

[Q1: 検索方法]
  ↓
ユーザー: 「ベクトル検索」
  ↓
Claude: 「ベクトル検索ですね。
次に、検索範囲について教えてください。」

[Q2: 検索範囲]
  ↓
ユーザー: 「WorkspaceとProject」
  ↓
Claude: 「両方のスコープで検索できるようにするのですね。
結果の表示順はどうしますか？」

[Q3: 表示順]
  ↓
ユーザー: 「類似度の高い順」
  ↓
Claude: 「類似度順ですね。
では、何件まで表示しますか？」

[Q4: 件数]
  ↓
ユーザー: 「デフォルト10件、最大100件」
  ↓
Claude: 「ありがとうございます。
要件が明確になりました：

- 検索方法: ベクトル検索
- 検索範囲: Workspace/Projectスコープ
- 表示順: 類似度の高い順
- 件数: デフォルト10件、最大100件

それでは開発のレールに乗ります...」
```

### 例2: バグ修正（一問一答）

```
ユーザー: 「メモリ保存時にエラーが出る」
  ↓
Claude: 「エラーが発生しているのですね。
まず、どのような操作でエラーが出るか教えてください。」

[Q1: 操作]
  ↓
ユーザー: 「新規メモリ作成時」
  ↓
Claude: 「新規作成時ですね。
エラーメッセージは何と表示されますか？」

[Q2: エラーメッセージ]
  ↓
ユーザー: 「Database connection failed」
  ↓
Claude: 「Database connection failedですね。
このエラーは毎回発生しますか？それとも時々ですか？」

[Q3: 再現性]
  ↓
ユーザー: 「必ず発生する」
  ↓
Claude: 「必ず発生するエラーですね。
いつ頃からこの問題が起きていますか？」

[Q4: 発生時期]
  ↓
ユーザー: 「昨日のデプロイ後から」
  ↓
Claude: 「ありがとうございます。
状況が明確になりました：

- 操作: 新規メモリ作成時
- エラー: Database connection failed
- 再現性: 必ず発生
- 発生時期: 昨日のデプロイ後

まず原因を調査します...」
```

## Claudeへの指示

**重要**: ヒアリングファースト手法を実践する際の指示

### 必ず実行すること

1. ✅ **一問一答形式でヒアリング**
   - **一度に一つの質問のみ**
   - 回答を受け取ってから次の質問
   - 前の回答に基づいて次の質問を調整

2. ✅ **最初のメッセージで即座に実装しない**
   - ユーザーからタスクを受け取ったら、まず理解を深める
   - 「実装します」の前に「確認させてください」

3. ✅ **AskUserQuestionツールを一問ずつ使う**
   - `questions`配列に**一つだけ**質問を入れる
   - 選択肢を提示して、ユーザーの意思決定を助ける
   - multiSelectを適切に使い分ける

4. ✅ **段階的にヒアリングする**
   - 大枠 → 詳細 → 技術的選択の順
   - 一つの質問の回答を受け取ってから次へ
   - ユーザーの回答に応じて次の質問を調整

5. ✅ **十分な情報が集まったら、開発フローに移行**
   - ヒアリング結果をサマリで提示
   - 「それでは以下の流れで進めます」と宣言
   - SPEC.md → DESIGN.md → 実装の順

6. ✅ **ヒアリング内容をドキュメントに反映**
   - SPEC.mdに「なぜこの仕様にしたか」を記録
   - ユーザーの意図や背景を明記

### 禁止事項

- ❌ いきなりコードを書き始める
- ❌ 曖昧なまま実装を進める
- ❌ 「たぶんこうだろう」で仮定する
- ❌ **一度に複数の質問をする（最重要）**
- ❌ ヒアリング内容を記録しない

### 一問一答のテンプレート

```
// ✅ 正しい使い方
Claude: 「まず〇〇について教えてください。」

[AskUserQuestion with 1 question]

// ユーザーの回答を待つ

// 回答を受け取った後
Claude: 「〇〇ですね。ありがとうございます。
次に△△について教えてください。」

[AskUserQuestion with 1 question]

// ユーザーの回答を待つ

// ...繰り返し
```

```
// ❌ 間違った使い方
Claude: 「以下について教えてください。」

[AskUserQuestion with 3-4 questions]

// ユーザーが圧倒される
```

## ヒアリングのパターン

### パターン1: 新機能追加

```
受信: 新機能の要望
  ↓
Q1: 機能の目的（Why）
  ↓
A1受信
  ↓
Q2: ユーザー体験（What）
  ↓
A2受信
  ↓
Q3: 技術的制約（How）
  ↓
A3受信
  ↓
...
  ↓
移行: SPEC.md作成
```

### パターン2: 既存機能の改善

```
受信: 改善要望
  ↓
Q1: 現状の何が問題か
  ↓
A1受信
  ↓
Q2: どうなれば理想か
  ↓
A2受信
  ↓
Q3: 既存機能への影響
  ↓
A3受信
  ↓
...
  ↓
移行: 該当spec/を確認 → 更新
```

### パターン3: バグ修正

```
受信: バグ報告
  ↓
Q1: 再現手順
  ↓
A1受信
  ↓
Q2: 期待する動作
  ↓
A2受信
  ↓
Q3: エラーメッセージ
  ↓
A3受信
  ↓
...
  ↓
移行: 調査 → 原因特定 → 修正
```

## ヒアリングシート（テンプレート）

一問一答で確認すべき項目のチェックリスト：

### 基本情報（Q1-Q3）
- [ ] Q1: 機能・タスクの名称
- [ ] Q2: 目的（Why）
- [ ] Q3: 背景・きっかけ

### 要件（Q4-Q7）
- [ ] Q4: 何を実現したいか（What）
- [ ] Q5: 誰が使うか（Who）
- [ ] Q6: どう動くべきか（How）
- [ ] Q7: 具体的な使用例

### 制約（Q8-Q11）
- [ ] Q8: 技術的制約
- [ ] Q9: パフォーマンス要件
- [ ] Q10: セキュリティ要件
- [ ] Q11: 互換性要件

### 関連性（Q12-Q14）
- [ ] Q12: 既存機能との関係
- [ ] Q13: 影響範囲
- [ ] Q14: 依存関係

### 優先度（Q15-Q17）
- [ ] Q15: 緊急度
- [ ] Q16: 重要度
- [ ] Q17: リリース時期

*注: 全ての質問が必要とは限りません。状況に応じて調整してください。*

## ベストプラクティス

### 良いヒアリング（一問一答） ✅

```
ユーザー: 「検索機能を改善して」
  ↓
Claude: 「検索機能の改善ですね。
まず、現在の検索で具体的にどのような点が不便か教えてください。」

[Q1: 不便な点]
  ↓
ユーザー: 「検索結果が不正確」
  ↓
Claude: 「検索結果の精度に課題があるのですね。
どのような検索をした時に、期待と異なる結果になりますか？
具体例があれば教えてください。」

[自由回答 or 選択肢提示]
  ↓
ユーザー: 「"プロジェクト管理"で検索しても関係ないメモリが出る」
  ↓
Claude: 「なるほど、キーワードが含まれていても
内容的に関係ないメモリが含まれてしまうのですね。

それでは、以下のような改善方法があります。
どれが良いでしょうか？」

[Q2: 改善方法]
Options:
  - ベクトル検索の導入（意味的な類似性で検索）
  - 検索フィルタの追加（タグ、日付など）
  - 検索アルゴリズムの改善（重み付け）
  - 複数を組み合わせ
  ↓
ユーザー: 「ベクトル検索」
  ↓
Claude: 「ベクトル検索を導入するのですね。
検索対象のスコープはどうしますか？」

[Q3: スコープ]
  ↓
...

✅ 一問一答で段階的に深掘り
✅ 前の回答に基づいて次の質問を調整
✅ ユーザーの負担が少ない
```

### 悪いヒアリング（複数質問を一度に） ❌

```
ユーザー: 「検索機能を改善して」
  ↓
Claude: 「わかりました。以下を教えてください：

1. 現在の検索の何が問題ですか？
2. どのような改善方法が良いですか？
3. 検索対象のスコープは？
4. 結果の表示順は？
5. パフォーマンス要件は？」

❌ 一度に5つも質問
❌ 後の質問は前の回答に依存する可能性
❌ ユーザーが圧倒される
❌ 不自然な会話フロー
```

## まとめ

> **「一問→一答→一問→一答→...→理解→レールに乗る」**

ヒアリングファーストは、開発の質を高めるための基礎です。
**一問一答形式**で段階的にヒアリングすることで、自然な会話フローを実現します。

**キーポイント**:
- 🎯 最初のメッセージで即座に実装しない
- 💬 AskUserQuestionツールを**一問ずつ**使う
- 📝 一つの回答を受け取ってから次の質問
- 🔄 前の回答に基づいて次の質問を調整
- 🚂 十分な理解が得られたら開発のレールへ
- 📖 ヒアリング内容をSPEC.mdに反映
- 😊 **ユーモアを忘れない**（堅苦しくならず、楽しく会話する）

**効果**:
- ✅ ユーザーの期待と実装のズレを防ぐ
- ✅ 手戻りを減らす
- ✅ 高品質なドキュメントが作成できる
- ✅ スムーズな開発フローに乗れる
- ✅ 自然な会話フローで負担が少ない
- ✅ Living Documentationが自然に実現できる

ヒアリングファーストは、Living Documentation原則と組み合わせることで、
「生きたドキュメント」と「ユーザーの期待に沿った実装」の両方を実現します。
